## Build nearest neighbor matrix from spNNGP ##
M = 10
NN.matrix <- NNMatrix(coords = coords, n.neighbors = M,
n.omp.threads = 2, search.type = "cb")
par(mfrow = c(1, 1))
Check_Neighbors(NN.matrix$coords.ord, n.neighbors = M, NN.matrix, 900)
save(list = ls(all.names = TRUE),
file = "./simulation/data/buildNN/nngp_10.RData", envir = .GlobalEnv)
setwd("./") # set to the path of ConjugateNNGP
setwd("./simulation")
rm(list = ls())
load("./data/buildNN/nngp_10.RData")
source("./src/functions.R")
library(foreach)
library(doParallel)
library(parallel)
library(rbenchmark)
#----------------
library(rbenchmark)
library(ggplot2)
# Create a data frame to store results
results <- data.frame(phi = numeric(), deltasq = numeric(), method = character(), time = numeric())
# Iterating over phi and deltasq values
for (phi_val in seq(1, 100, by = 20)) {
for (deltasq_val in seq(0, 1, by = 0.2)) {
# [Insert code to compute XTX_star, XTY_star based on phi_val and deltasq_val]
delta <- sqrt(deltasq_val)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi_val)
D <- AD[M + 1, ]
## generate sparse matrix X* and Y*
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
# Benchmarking each method
try({
bm_cgsparse <- benchmark(cgsparse(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_cgsparse <- bm_cgsparse$elapsed
}, silent = TRUE)
try({
bm_solveCG_Ident <- benchmark(solveCGwithIdentityPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Ident <- bm_solveCG_Ident$elapsed
}, silent = TRUE)
try({
bm_solveCG_Diag <- benchmark(solveCGwithDiagonalPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Diag <- bm_solveCG_Diag$elapsed
}, silent = TRUE)
# Storing results
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "cgsparse", time = ifelse(exists("elapsed_cgsparse"), elapsed_cgsparse, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Ident", time = ifelse(exists("elapsed_solveCG_Ident"), elapsed_solveCG_Ident, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Diag", time = ifelse(exists("elapsed_solveCG_Diag"), elapsed_solveCG_Diag, 0)))
}
}
# Plotting the results
ggplot(results, aes(x = phi, y = time, color = method)) +
geom_line() +
facet_wrap(~deltasq) +
labs(title = "Benchmarking of CG Methods", x = "Phi Value", y = "Time (elapsed)", color = "Method")
# Iterating over phi and deltasq values
for (phi_val in seq(5, 55, by = 5)) {
for (deltasq_val in seq(0.05, 0.15, by = 0.01)) {
# [Insert code to compute XTX_star, XTY_star based on phi_val and deltasq_val]
delta <- sqrt(deltasq_val)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi_val)
D <- AD[M + 1, ]
## generate sparse matrix X* and Y*
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
# Benchmarking each method
try({
bm_cgsparse <- benchmark(cgsparse(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_cgsparse <- bm_cgsparse$elapsed
}, silent = TRUE)
try({
bm_solveCG_Ident <- benchmark(solveCGwithIdentityPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Ident <- bm_solveCG_Ident$elapsed
}, silent = TRUE)
try({
bm_solveCG_Diag <- benchmark(solveCGwithDiagonalPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Diag <- bm_solveCG_Diag$elapsed
}, silent = TRUE)
# Storing results
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "cgsparse", time = ifelse(exists("elapsed_cgsparse"), elapsed_cgsparse, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Ident", time = ifelse(exists("elapsed_solveCG_Ident"), elapsed_solveCG_Ident, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Diag", time = ifelse(exists("elapsed_solveCG_Diag"), elapsed_solveCG_Diag, 0)))
}
}
# Plotting the results
ggplot(results, aes(x = phi, y = time, color = method)) +
geom_line() +
facet_wrap(~deltasq) +
labs(title = "Benchmarking of CG Methods", x = "Phi Value", y = "Time (elapsed)", color = "Method")
# Iterating over phi and deltasq values
for (phi_val in seq(5, 80, by = 5)) {
for (deltasq_val in seq(0.05, 0.25, by = 0.01)) {
# [Insert code to compute XTX_star, XTY_star based on phi_val and deltasq_val]
delta <- sqrt(deltasq_val)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi_val)
D <- AD[M + 1, ]
## generate sparse matrix X* and Y*
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
# Benchmarking each method
try({
bm_cgsparse <- benchmark(cgsparse(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_cgsparse <- bm_cgsparse$elapsed
}, silent = TRUE)
try({
bm_solveCG_Ident <- benchmark(solveCGwithIdentityPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Ident <- bm_solveCG_Ident$elapsed
}, silent = TRUE)
try({
bm_solveCG_Diag <- benchmark(solveCGwithDiagonalPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Diag <- bm_solveCG_Diag$elapsed
}, silent = TRUE)
# Storing results
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "cgsparse", time = ifelse(exists("elapsed_cgsparse"), elapsed_cgsparse, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Ident", time = ifelse(exists("elapsed_solveCG_Ident"), elapsed_solveCG_Ident, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Diag", time = ifelse(exists("elapsed_solveCG_Diag"), elapsed_solveCG_Diag, 0)))
}
}
# Plotting the results
ggplot(results, aes(x = phi, y = time, color = method)) +
geom_line() +
facet_wrap(~deltasq) +
labs(title = "Benchmarking of CG Methods", x = "Phi Value", y = "Time (elapsed)", color = "Method")
#----------------
library(rbenchmark)
library(ggplot2)
# Create a data frame to store results
results <- data.frame(phi = numeric(), deltasq = numeric(), method = character(), time = numeric())
# Iterating over phi and deltasq values
for (phi_val in seq(5, 80, by = 5)) {
for (deltasq_val in seq(0.05, 0.25, by = 0.01)) {
# [Insert code to compute XTX_star, XTY_star based on phi_val and deltasq_val]
delta <- sqrt(deltasq_val)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi_val)
D <- AD[M + 1, ]
## generate sparse matrix X* and Y*
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
# Benchmarking each method
try({
bm_cgsparse <- benchmark(cgsparse(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_cgsparse <- bm_cgsparse$elapsed
}, silent = TRUE)
try({
bm_solveCG_Ident <- benchmark(solveCGwithIdentityPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Ident <- bm_solveCG_Ident$elapsed
}, silent = TRUE)
try({
bm_solveCG_Diag <- benchmark(solveCGwithDiagonalPreconditioner(XTX_star, XTY_star[1:(N + P)]), replications = 1000)
elapsed_solveCG_Diag <- bm_solveCG_Diag$elapsed
}, silent = TRUE)
# Storing results
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "cgsparse", time = ifelse(exists("elapsed_cgsparse"), elapsed_cgsparse, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Ident", time = ifelse(exists("elapsed_solveCG_Ident"), elapsed_solveCG_Ident, 0)))
results <- rbind(results, data.frame(phi = phi_val, deltasq = deltasq_val, method = "solveCG_Diag", time = ifelse(exists("elapsed_solveCG_Diag"), elapsed_solveCG_Diag, 0)))
}
}
# Plotting the results
ggplot(results, aes(x = phi, y = time, color = method)) +
geom_line() +
facet_wrap(~deltasq) +
labs(title = "Benchmarking of CG Methods", x = "Phi Value", y = "Time (elapsed)", color = "Method") +
ylim(0, 10)  # Setting the y-axis limits
#----------------
ggplot(results, aes(x = deltasq, y = time, color = method)) +
geom_line() +
facet_wrap(~phi) +
labs(title = "Benchmarking of CG Methods", x = "deltasq Value", y = "Time (elapsed)", color = "Method")   # Setting the y-axis limits
## set estimates for phi and deltasq from cross-validation "spConjNNGP" ##
phi <- 17.64706; deltasq <- 0.09000
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#symbolic Cholesky decomposition#
#Eigen's SimplicialLLT solver does not provide a direct way to separate symbolic and numeric factorization in the manner you're seeking. The solver combines both these steps internally in the factorize method.This limitation means you'll need to perform the full decomposition for each matrix, but the solver will internally optimize the process when the sparsity pattern remains unchanged.#
solver <- new(CholeskySolver)
benchmark(solver$solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
xttt=solver$solve(XTX_star, XTY_star[1:(N + P)])
summary(gamma_hat-xttt)
## set estimates for phi and deltasq from cross-validation "spConjNNGP" ##
phi <- 16.64706; deltasq <- 0.09000
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#symbolic Cholesky decomposition#
#Eigen's SimplicialLLT solver does not provide a direct way to separate symbolic and numeric factorization in the manner you're seeking. The solver combines both these steps internally in the factorize method.This limitation means you'll need to perform the full decomposition for each matrix, but the solver will internally optimize the process when the sparsity pattern remains unchanged.#
solver <- new(CholeskySolver)
benchmark(solver$solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
#symbolic Cholesky decomposition#
#Eigen's SimplicialLLT solver does not provide a direct way to separate symbolic and numeric factorization in the manner you're seeking. The solver combines both these steps internally in the factorize method.This limitation means you'll need to perform the full decomposition for each matrix, but the solver will internally optimize the process when the sparsity pattern remains unchanged.#
solver <- new(CholeskySolver)
benchmark(solver$solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
xttt=solver$solve(XTX_star, XTY_star[1:(N + P)])
summary(gamma_hat-xttt)
## set estimates for phi and deltasq from cross-validation "spConjNNGP" ##
phi <- 10.64706; deltasq <- 0.08000
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#symbolic Cholesky decomposition#
#Eigen's SimplicialLLT solver does not provide a direct way to separate symbolic and numeric factorization in the manner you're seeking. The solver combines both these steps internally in the factorize method.This limitation means you'll need to perform the full decomposition for each matrix, but the solver will internally optimize the process when the sparsity pattern remains unchanged.#
solver <- new(CholeskySolver)
benchmark(solver$solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
xttt=solver$solve(XTX_star, XTY_star[1:(N + P)])
summary(gamma_hat-xttt)
## set estimates for phi and deltasq from cross-validation "spConjNNGP" ##
phi <- 17.64706; deltasq <- 5
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#symbolic Cholesky decomposition#
#Eigen's SimplicialLLT solver does not provide a direct way to separate symbolic and numeric factorization in the manner you're seeking. The solver combines both these steps internally in the factorize method.This limitation means you'll need to perform the full decomposition for each matrix, but the solver will internally optimize the process when the sparsity pattern remains unchanged.#
solver <- new(CholeskySolver)
benchmark(solver$solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
xttt=solver$solve(XTX_star, XTY_star[1:(N + P)])
summary(gamma_hat-xttt)
## set estimates for phi and deltasq from cross-validation "spConjNNGP" ##
phi <- 17.64706; deltasq <- 10
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
## obtain A and D using C and N(i)
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
#Dsqrtinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1 / sqrt(D))
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#symbolic Cholesky decomposition#
#Eigen's SimplicialLLT solver does not provide a direct way to separate symbolic and numeric factorization in the manner you're seeking. The solver combines both these steps internally in the factorize method.This limitation means you'll need to perform the full decomposition for each matrix, but the solver will internally optimize the process when the sparsity pattern remains unchanged.#
solver <- new(CholeskySolver)
benchmark(solver$solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
xttt=solver$solve(XTX_star, XTY_star[1:(N + P)])
summary(gamma_hat-xttt)
benchmark(solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
xttt=solve(XTX_star, XTY_star[1:(N + P)])
summary(gamma_hat-xttt)
# Plotting the results
ggplot(results, aes(x = phi, y = time, color = method)) +
geom_line() +
facet_wrap(~deltasq) +
labs(title = "Benchmarking of CG Methods", x = "Phi Value", y = "Time (elapsed)", color = "Method") +
ylim(0, 10)  # Setting the y-axis limits
setwd("./") # set to the path of ConjugateNNGP
rm(list = ls())
load("./nngp_10.RData")
source("./functions.R")
library(foreach)
library(doParallel)
library(parallel)
library(rbenchmark)
library(rbenchmark)
library(ggplot2)
phi <- 17.64706; deltasq <- 10
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#standard solve#
solver <- new(CholeskySolver)
benchmark(solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),
solver$solve(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
setwd("./") # set to the path of ConjugateNNGP
rm(list = ls())
load("./nngp_10.RData")
source("./functions.R")
library(foreach)
library(doParallel)
library(parallel)
library(rbenchmark)
library(rbenchmark)
library(ggplot2)
phi <- 17.64706; deltasq <- 10
delta <- sqrt(deltasq)
a = as; b = bs;
ind_x <-c(c(rep(2:M, times = 1:(M - 1)), rep(((M + 1) : N), each = M)), 1:N)
ind_y <- c(c(t(NN.matrix$NN_ind))[which(c(t(NN.matrix$NN_ind)) > 0)], 1:N)
X.ord <- X[NN.matrix$ord, ]
Y.ord <- Y[NN.matrix$ord]
AD <- getADstan(neardist = NN.matrix$NN_dist,  neardistM = NN.matrix$NN_distM,
N = N, M = M, phi = phi)
D <- AD[M + 1, ]
ind_x_X <- rep(1:N, P); ind_y_X <- rep(1:P, each = N)
ind_x_X_up <- c(ind_x_X, 1:N)
ind_y_X_up <- c(ind_y_X, (P + 1):(N + P))
X_star_up <-
sparseMatrix(ind_x_X_up, ind_y_X_up, x = c(as.vector(X.ord) / delta,
rep(1 / delta, N)))
X_star_down <-
sparseMatrix(i = ind_x, j = (ind_y + P),
x = c(-na.omit(as.vector(AD[-(M + 1), ])), rep(1, N))) /
sqrt(D)
X_star <- rbind(X_star_up, X_star_down)
Y_star <- c(Y.ord / delta, rep(0, N))
XTY_star <- crossprod(X_star, Y_star)
XTX_star <- crossprod(X_star, X_star)
#time compare with#
solver <- new(CholeskySolver)
benchmark(solve(XTX_star, XTY_star[1:(N + P)]),
cgsparse(XTX_star, XTY_star[1:(N + P)]),
solver$solve(XTX_star, XTY_star[1:(N + P)]),replications = 1000)
